R=length(brks.list[[1]])+1
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
# calculate P(Z1=1,Z2=1)
# P(Z1=1|X)
pi_marg_j_vec =  expit.f(res_s1$est[R+1,1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi_marg_jp_vec =  expit.f(res_s1$est[2*(R+1),1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi11_est <- pi11_pw.f(pi_marg_j_vec, pi_marg_jp_vec, res_s2$res[[l]]$par[2])
Tmax.turnbull = dt.Turnbull_cdfCI.f(data=dt_1, nsim=100, nsample=length(unique(dt_1$id)))
x=seq(0,40, length.out = 40)
y= marg.maxT12.f(x, res_s1$brks[[1]], exp(phi1_est.list[[1]][1:R]),
res_s1$brks[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1], mean(pi11_est))
lines(x,y, type="l", col="red")
}
plot.Fit_Tmin.f <- function(l, abd.mat, indt_s2.list, res_s1, res_s2){
abd_vec = abd.mat[l,]
dt_1 = subset(indt_s2.list$dt, (indt_s2.list$abcd[,1]==abd_vec[1] & indt_s2.list$abcd[,2]==abd_vec[2]
& indt_s2.list$abcd[,4]==abd_vec[3]) )
dt_1$l = dt_1$l_j
dt_1$l[dt_1$l_j>=dt_1$l_jp] = dt_1$l_jp[dt_1$l_j>=dt_1$l_jp]
dt_1$r = dt_1$r_j
dt_1$r[dt_1$l_j>=dt_1$l_jp] = dt_1$r_jp[dt_1$l_j>=dt_1$l_jp]
# model-based P(max(T1, T2) <= t)
brks.list = res_s1$brks
R=length(brks.list[[1]])+1
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
# calculate P(Z1=1,Z2=1)
# P(Z1=1|X)
pi_marg_j_vec =  expit.f(res_s1$est[R+1,1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi_marg_jp_vec =  expit.f(res_s1$est[2*(R+1),1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi11_est <- pi11_pw.f(pi_marg_j_vec, pi_marg_jp_vec, res_s2$res[[l]]$par[2])
Tmax.turnbull = dt.Turnbull_cdfCI.f(data=dt_1, nsim=100, nsample=length(unique(dt_1$id)))
x=seq(0,40, length.out = 40)
#y= marg.maxT12.f(x, brks.list[[1]], exp(phi1_est.list[[1]][1:R]),
#                 brks.list[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1], mean(pi11_est))
y=marg.minT12.f(x, brks.list[[1]], exp(phi1_est.list[[1]][1:R]),
brks.list[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1],
mean(pi_marg_j_vec), mean(pi_marg_jp_vec), mean(pi11_est))
lines(x,y, type="l", col="red")
}
R = length(q.brks.cuts) + 1
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
indt_s2.list <- create_df_s2_abcd.f(Kj_vec, indata_s1.list=res_s1$dt, marg.type)
res_s2 <- realdt_est_s2_abcd.f(phi1_est.list, brks.list=res_s1$brks,
indata_s2=indt_s2.list$dt,
Ind_abcd.mat=indt_s2.list$abcd, marg.type)
# inference
cat("stage II inference begins ...", "\n")
indata_s1 = do.call("rbind", res_s1$dt)
Hess_phi2.list <- lapply(res_s2$res, function(x) x$hessian)
phi2.list = lapply(res_s2$res, function(x) x$par)
s2_ase.list <- realdt_s2_asvar.f(Hess_s1=res_s1$org.fit$hessian, Hess_phi2.list,
gradstep=1e-06,
phi1=res_s1$est[,1], brks.list=res_s1$brks, indata_s1,
phi2.list, df_s2.list=res_s2$dt,
marg.type, num.cores=2)
# h(Y) = h(Y0) + h'(Y0)(Y-Y0)
phi2.mat = do.call("rbind", phi2.list)
dh_vec = as.vector(rbind((2/pi)^2/(sqrt(1-(atan(phi2.mat[,1])*(2/pi)^2)^2)*(1+phi2.mat[,1]^2)), exp(phi2.mat[,2])))
asvar_hY = diag(dh_vec) %*% s2_ase.list$asvar %*% diag(dh_vec)
ase_hY = sqrt(diag((asvar_hY)))
h_phi2 = as.vector(rbind(asin((2/pi)^2*atan(phi2.mat[,1])), exp(phi2.mat[,2])))
h_p_val = round((1- pnorm(abs(h_phi2/ase_hY))),4)
# 95% CI
h_CI = cbind(h_phi2 - qnorm(0.975)*ase_hY, h_phi2 + qnorm(0.975)*ase_hY)
h_res = cbind(h_phi2, h_CI, h_p_val)
colnames(h_res) = c("est", "lb", "ub", "p-value")
rownames(h_res) = c("tau_row", "OR_row",
"tau_ray", "OR_ray",
"tau_0", "OR_0",
"tau_sym", "OR_sym")
dh1_vec = as.vector(rbind((2/pi)^2/(sqrt(1-(atan(phi2.mat[,1])*(2/pi)^2)^2)*(1+phi2.mat[,1]^2)),  rep(1, length(phi2.mat[,2]))))
asvar_h1Y = diag(dh1_vec) %*% s2_ase.list$asvar %*% diag(dh1_vec)
ase_h1Y = sqrt(diag((asvar_h1Y)))
h1_phi2 = as.vector(rbind(asin((2/pi)^2*atan(phi2.mat[,1])), phi2.mat[,2]))
h1_p_val = round((1- pnorm(abs(h1_phi2/ase_h1Y))),4)
# 95% CI
h1_CI = cbind(h1_phi2 - qnorm(0.975)*ase_h1Y, h1_phi2 + qnorm(0.975)*ase_h1Y)
h1_res = cbind(h1_phi2, h1_CI, h1_p_val)
colnames(h1_res) = c("est", "lb", "ub", "p-value")
rownames(h1_res) = c("tau_row", "OR_row",
"tau_ray", "OR_ray",
"tau_0", "OR_0",
"tau_sym", "OR_sym")
abcd.mat = unique(indt_s2.list$abcd)
abd.mat = unique(abcd.mat[,-3])
zero.mat <- matrix(0, nrow=length(phi2.list), ncol=length(phi2.list))
ext_abd.mat_x <- cbind(rep(1,dim(abd.mat)[1]), abd.mat, zero.mat)
ext_abd.mat_y <- cbind(zero.mat, rep(1,dim(abd.mat)[1]), abd.mat)
ext_abd.mat <- NULL
inv.ext_abd.mat = ginv(ext_abd.mat)
for(l in 1:dim(ext_abd.mat_x)[1]){
ext_abd.mat <- rbind(ext_abd.mat, ext_abd.mat_x[l,], ext_abd.mat_y[l,])
}
tr.phi2.est <- inv.ext_abd.mat %*% unlist(phi2.list)
ext_abd.mat <- NULL
for(l in 1:dim(ext_abd.mat_x)[1]){
ext_abd.mat <- rbind(ext_abd.mat, ext_abd.mat_x[l,], ext_abd.mat_y[l,])
}
inv.ext_abd.mat = ginv(ext_abd.mat)
tr.phi2.est <- inv.ext_abd.mat %*% unlist(phi2.list)
tr.s2asvar <- inv.ext_abd.mat %*% s2_ase.list$asvar %*% t(inv.ext_abd.mat)
tr.s2ase <- sqrt(diag(tr.s2asvar))
p_val = round(1-pnorm(abs(tr.phi2.est/tr.s2ase)), 4) #round(1-pnorm(abs(unlist(phi2.list)/s2_ase.list$ase)),3)
res = cbind(tr.phi2.est, tr.s2ase, p_val)
rownames(res) = c(paste0("rho_dgr_", c("0", "sdist", "sdigit", "symmetric")),
paste0("logOR_", c("0", "sdist", "sdigit", "symmetric")))
res_s2.list <- list(est=res,
org.fit=res_s2,
org.asvar=s2_ase.list,
h_est=h_res,
h1_est =h1_res)
res.list = list(s1=res_s1,
s2=res_s2.list)
# max(T1, T2)
abcd.mat = unique(indt_s2.list$abcd)
abd.mat = unique(abcd.mat[,-3])
# ---------- max(T1, T2) ----------
# row
pdf("row_CDF_Tmax.pdf")
plot.Fit_Tmax.f(1, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
# max(T1, T2)
abcd.mat = unique(indt_s2.list$abcd)
abd.mat = unique(abcd.mat[,-3])
# symmetric
abd_vec = abd.mat[4,]
dt_sym = subset(indt_s2.list$dt, (indt_s2.list$abcd[,1]==abd_vec[1] & indt_s2.list$abcd[,2]==abd_vec[2]
& indt_s2.list$abcd[,4]==abd_vec[3]) )
dt_sym$l = dt_sym$l_j
dt_sym$l[dt_sym$r_j<=dt_sym$r_jp] = dt_sym$l_jp[dt_sym$r_j<=dt_sym$r_jp]
dt_sym$r = dt_sym$r_j
dt_sym$r[dt_sym$r_j<=dt_sym$r_jp] = dt_sym$r_jp[dt_sym$r_j<=dt_sym$r_jp]
# plot of Turnbull estimate of max(T1, T2)
#install.packages("icenReg")
#library(icenReg)
#help(package=icenReg)
Tmax_sym.turnbull = dt.Turnbull_cdfCI.f(data=dt_sym, nsim=100, nsample=length(unique(dt_sym$id)))
Tmax_sym.turnbull
dt_sym_min = dt_sym
dt_sym_min$l = dt_sym$l_j
dt_sym_min$l[dt_sym$l_j>=dt_sym$l_jp] = dt_sym$l_jp[dt_sym$l_j>=dt_sym$l_jp]
dt_sym_min$r = dt_sym$r_j
dt_sym_min$r[dt_sym$l_j>=dt_sym$r_jp] = dt_sym$r_jp[dt_sym$l_j>=dt_sym$r_jp]
Tmin_sym.turnbull = dt.Turnbull_cdfCI.f(data=dt_sym_min, nsim=100, nsample=length(unique(dt_sym_min$id)))
R=length(brks.list[[1]])+1
# model-based P(max(T1, T2) <= t)
brks.list = res_s1$brks
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
source('~/Dropbox/richard/coding-pj2/real_data/fit_fct.R')
plot.Fit_Tmax.f <- function(l, abd.mat, indt_s2.list, res_s1, res_s2){
abd_vec = abd.mat[l,]
dt_1 = subset(indt_s2.list$dt, (indt_s2.list$abcd[,1]==abd_vec[1] & indt_s2.list$abcd[,2]==abd_vec[2]
& indt_s2.list$abcd[,4]==abd_vec[3]) )
dt_1$l = dt_1$l_j
dt_1$l[dt_1$r_j<=dt_1$r_jp] = dt_1$l_jp[dt_1$r_j<=dt_1$r_jp]
dt_1$r = dt_1$r_j
dt_1$r[dt_1$r_j<=dt_1$r_jp] = dt_1$r_jp[dt_1$r_j<=dt_1$r_jp]
# model-based P(max(T1, T2) <= t)
brks.list = res_s1$brks
R=length(brks.list[[1]])+1
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
# calculate P(Z1=1,Z2=1)
# P(Z1=1|X)
pi_marg_j_vec =  expit.f(res_s1$est[R+1,1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi_marg_jp_vec =  expit.f(res_s1$est[2*(R+1),1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi11_est <- pi11_pw.f(pi_marg_j_vec, pi_marg_jp_vec, res_s2$res[[l]]$par[2])
Tmax.turnbull = dt.Turnbull_cdf.f(data=dt_1, nsim=100, nsample=length(unique(dt_1$id)))
x=seq(0,40, length.out = 40)
y= marg.maxT12.f(x, res_s1$brks[[1]], exp(phi1_est.list[[1]][1:R]),
res_s1$brks[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1], mean(pi11_est))
lines(x,y, type="l", col="red")
}
# ---------- max(T1, T2) ----------
# row
pdf("row_CDF_Tmax.pdf", width=5, height=5)
plot.Fit_Tmax.f(1, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
plot.Fit_Tmax.f <- function(l, abd.mat, indt_s2.list, res_s1, res_s2){
abd_vec = abd.mat[l,]
dt_1 = subset(indt_s2.list$dt, (indt_s2.list$abcd[,1]==abd_vec[1] & indt_s2.list$abcd[,2]==abd_vec[2]
& indt_s2.list$abcd[,4]==abd_vec[3]) )
dt_1$l = dt_1$l_j
dt_1$l[dt_1$r_j<=dt_1$r_jp] = dt_1$l_jp[dt_1$r_j<=dt_1$r_jp]
dt_1$r = dt_1$r_j
dt_1$r[dt_1$r_j<=dt_1$r_jp] = dt_1$r_jp[dt_1$r_j<=dt_1$r_jp]
# model-based P(max(T1, T2) <= t)
brks.list = res_s1$brks
R=length(brks.list[[1]])+1
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
# calculate P(Z1=1,Z2=1)
# P(Z1=1|X)
pi_marg_j_vec =  expit.f(res_s1$est[R+1,1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi_marg_jp_vec =  expit.f(res_s1$est[2*(R+1),1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi11_est <- pi11_pw.f(pi_marg_j_vec, pi_marg_jp_vec, res_s2$res[[l]]$par[2])
Tmax.turnbull = dt.Turnbull_cdf.f(data=dt_1, nsample=length(unique(dt_1$id)))
x=seq(0,40, length.out = 40)
y= marg.maxT12.f(x, res_s1$brks[[1]], exp(phi1_est.list[[1]][1:R]),
res_s1$brks[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1], mean(pi11_est))
lines(x,y, type="l", col="red")
}
plot.Fit_Tmin.f <- function(l, abd.mat, indt_s2.list, res_s1, res_s2){
abd_vec = abd.mat[l,]
dt_1 = subset(indt_s2.list$dt, (indt_s2.list$abcd[,1]==abd_vec[1] & indt_s2.list$abcd[,2]==abd_vec[2]
& indt_s2.list$abcd[,4]==abd_vec[3]) )
dt_1$l = dt_1$l_j
dt_1$l[dt_1$l_j>=dt_1$l_jp] = dt_1$l_jp[dt_1$l_j>=dt_1$l_jp]
dt_1$r = dt_1$r_j
dt_1$r[dt_1$l_j>=dt_1$l_jp] = dt_1$r_jp[dt_1$l_j>=dt_1$l_jp]
# model-based P(max(T1, T2) <= t)
brks.list = res_s1$brks
R=length(brks.list[[1]])+1
phi1_est.list <- list(res_s1$est[c(1:(R+1), 2*(R+1)+(1:length(res_s1$covar))),1],
res_s1$est[c((R+1)+(1:(R+1)), 2*(R+1)+(1:length(res_s1$covar))),1])
# calculate P(Z1=1,Z2=1)
# P(Z1=1|X)
pi_marg_j_vec =  expit.f(res_s1$est[R+1,1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi_marg_jp_vec =  expit.f(res_s1$est[2*(R+1),1] +
as.matrix(dt_1[,paste0("x",1:(length(res_s1$covar)))]) %*% res_s1$est[-(1:(2*(R+1))),1])
pi11_est <- pi11_pw.f(pi_marg_j_vec, pi_marg_jp_vec, res_s2$res[[l]]$par[2])
Tmax.turnbull = dt.Turnbull_cdf.f(data=dt_1, nsample=length(unique(dt_1$id)))
x=seq(0,40, length.out = 40)
#y= marg.maxT12.f(x, brks.list[[1]], exp(phi1_est.list[[1]][1:R]),
#                 brks.list[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1], mean(pi11_est))
y=marg.minT12.f(x, brks.list[[1]], exp(phi1_est.list[[1]][1:R]),
brks.list[[2]], exp(phi1_est.list[[2]][1:R]), res_s2$res[[l]]$par[1],
mean(pi_marg_j_vec), mean(pi_marg_jp_vec), mean(pi11_est))
lines(x,y, type="l", col="red")
}
# ---------- min(T1, T2) ----------
# row
pdf("row_CDF_Tmin.pdf", width=5, height=5)
plot.Fit_Tmin.f(1, abd.mat, indt_s2.list, res_s1, res_s2)
#mtext("row: min(T1, T2)", side = 3)
dev.off()
# ---------- max(T1, T2) ----------
# row
pdf("row_CDF_Tmax.pdf", width=5, height=5)
plot.Fit_Tmax.f(1, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
#mtext("row", side = 3)
# ray
pdf("ray_CDF_Tmax.pdf", width=5, height=5)
plot.Fit_Tmax.f(2, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
#mtext("ray", side = 3)
# baseline
pdf("base_CDF_Tmax.pdf", width=5, height=5)
plot.Fit_Tmax.f(3, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
#mtext("baseline", side = 3)
# symmetric
pdf("sym_CDF_Tmax.pdf", width=5, height=5)
plot.Fit_Tmax.f(4, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
# ---------- min(T1, T2) ----------
# row
pdf("row_CDF_Tmin.pdf", width=5, height=5)
plot.Fit_Tmin.f(1, abd.mat, indt_s2.list, res_s1, res_s2)
#mtext("row: min(T1, T2)", side = 3)
dev.off()
#mtext("baseline", side = 3)
# symmetric
pdf("sym_CDF_Tmax.pdf", width=4.5, height=4.5)
plot.Fit_Tmax.f(4, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
#mtext("baseline", side = 3)
# symmetric
pdf("sym_CDF_Tmax.pdf", width=4, height=4)
plot.Fit_Tmax.f(4, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
#mtext("baseline", side = 3)
# symmetric
pdf("sym_CDF_Tmax.pdf", width=4.3, height=4.3)
plot.Fit_Tmax.f(4, abd.mat, indt_s2.list, res_s1, res_s2)
dev.off()
pdf("Lexis_15.pdf", width=4.5, height=4.5)
par(mgp=c(5,1,0))
par(mar=c(4,4,3,2)+0.1)
plot(0,0,type="n",axes=F,xlim=c(1930,2020),ylim=c(0,100),xlab="",ylab="")
axis(side=1, at=seq(1930,2020,by=10), label=T, cex.axis=0.75)
axis(side=2, at=seq(0,100,by=20), label=T, adj=1, cex.axis=0.75)
mtext("CALENDAR YEAR", side=1, line=1.8, cex=0.8)
mtext("AGE", side=2, line=1.8, cex=0.8)
lines(psc.to.psa, lty=3, lwd=1)
#lines(psc.to.entry, lty=1, lwd=1);
#lines(psa.to.entry, lty=1, lwd=1);
lines(followup, lty=1, lwd=1)
points(psc.to.entry, pch=108, cex=0.5)
points(subset(followup, status(followup) %in% 1), pch=1, cex=0.5)
box()
dev.off()
pdf("Lexis_15.pdf", width=4.8, height=4.8)
par(mgp=c(5,1,0))
par(mar=c(4,4,3,2)+0.1)
plot(0,0,type="n",axes=F,xlim=c(1930,2020),ylim=c(0,100),xlab="",ylab="")
axis(side=1, at=seq(1930,2020,by=10), label=T, cex.axis=0.75)
axis(side=2, at=seq(0,100,by=20), label=T, adj=1, cex.axis=0.75)
mtext("CALENDAR YEAR", side=1, line=1.8, cex=0.8)
mtext("AGE", side=2, line=1.8, cex=0.8)
lines(psc.to.psa, lty=3, lwd=1)
#lines(psc.to.entry, lty=1, lwd=1);
#lines(psa.to.entry, lty=1, lwd=1);
lines(followup, lty=1, lwd=1)
points(psc.to.entry, pch=108, cex=0.5)
points(subset(followup, status(followup) %in% 1), pch=1, cex=0.5)
box()
dev.off()
library(mipfp)
setwd("~/Dropbox/richard/coding-pj2/sim1")
library(Rcpp)
library(Rsolnp)
setwd("~/Dropbox/richard/coding-pj2/sim1")
library(MASS)
library(NlcOptim)
library(eha)
library(parallel)
library(mnormt)
library(poisson)
library(pbivnorm)
sourceCpp("commonf.cpp")
sourceCpp("loglik.cpp")
source("dataGen_fct.R")
source("est_fct.R")
source("ts_inference_fct.R")
# -------- Parameter preparation --------- #
# prepare stage I params: alp_j_vec, eta_j_vec
eta_10 = sol.eta_0.f(pi1, eta_11_vec, c(prob.x, prob.g))
eta_20 = sol.eta_0.f(pi2, eta_21_vec, c(prob.x, prob.g))
eta_30 = sol.eta_0.f(pi3, eta_31_vec, c(prob.x, prob.g))
prob.g=0.05
prob.g=0.05
prob.x=0.45
nsample=2000
K1=2
K2=6
K3=6
pi1=0.2
pi2=0.05
pi3=0.05
eta_11_vec=c(0.2, 0
)
eta_21_vec=c(0.2, 0)
eta_31_vec=c(0.2, 0)
SurvP.ctr1= 0.9
SurvP.ctr2=0.85
SurvP.ctr3=0.85
brks_1_vec=0.55
brks_2_vec=0.55
brks_3_vec=0.55
or_11=1.2
or_22=1.2
or_33=1.2
or_12=1.05
or_13=1.05
or_23=1.05
tau_11=0.15
tau_22=0.15
tau_33=0.15
tau_12=0.05
tau_13=0.05
tau_23=0.05
visit.rate=5
marg.type = "gene-common"
pair.type = "jjp"
# -------- Parameter preparation --------- #
# prepare stage I params: alp_j_vec, eta_j_vec
eta_10 = sol.eta_0.f(pi1, eta_11_vec, c(prob.x, prob.g))
eta_20 = sol.eta_0.f(pi2, eta_21_vec, c(prob.x, prob.g))
eta_30 = sol.eta_0.f(pi3, eta_31_vec, c(prob.x, prob.g))
eta_1_vec = c(eta_10, eta_11_vec); eta_2_vec = c(eta_20, eta_21_vec); eta_3_vec = c(eta_30, eta_31_vec)
scale_1 = sol.scale.f(SurvP.ctr1, 1, kappa_1)
kappa_1=1
kappa_2=1
kappa_3=1
scale_1 = sol.scale.f(SurvP.ctr1, 1, kappa_1)
scale_2 = sol.scale.f(SurvP.ctr2, 1, kappa_2)
scale_3 = sol.scale.f(SurvP.ctr3, 1, kappa_3)
# prepare stage II params: pi_pair_mat, cor_mat, Pjoint_Z_g_XG
pi_pair_mat.res = create_pi_pair_mat.f(K1, K2, K3, pi1, pi2, pi3, or_11, or_22, or_33, or_12, or_13, or_23)
pi_pair_mat = pi_pair_mat.res$pi_pair_mat
cor_mat = create_cor_mat.f(K1, K2, K3, tau_11, tau_22, tau_33, tau_12, tau_13, tau_23)
pjoint_Z_g_11 = J3_Pjoint_Z_g_XG.f(K1, K2, K3, eta_1_vec, eta_2_vec, eta_3_vec, 1, 1,
pi_pair_mat,
pi_pair_mat.res$pi11, pi_pair_mat.res$pi22, pi_pair_mat.res$pi33,
pi_pair_mat.res$pi12, pi_pair_mat.res$pi13, pi_pair_mat.res$pi23)
if(any(pjoint_Z_g_11<0)){stop("pjoint_Z_g_11 is not legistimate !")}
pjoint_Z_g_10 = J3_Pjoint_Z_g_XG.f(K1, K2, K3, eta_1_vec, eta_2_vec, eta_3_vec, 1, 0, pi_pair_mat,
pi_pair_mat.res$pi11, pi_pair_mat.res$pi22,
pi_pair_mat.res$pi33, pi_pair_mat.res$pi12,
pi_pair_mat.res$pi13, pi_pair_mat.res$pi23)
if(any(pjoint_Z_g_10<0)){stop("pjoint_Z_g_10 is not legistimate !")}
pjoint_Z_g_01 = J3_Pjoint_Z_g_XG.f(K1, K2, K3, eta_1_vec, eta_2_vec, eta_3_vec, 0, 1, pi_pair_mat,
pi_pair_mat.res$pi11, pi_pair_mat.res$pi22,
pi_pair_mat.res$pi33, pi_pair_mat.res$pi12,
pi_pair_mat.res$pi13, pi_pair_mat.res$pi23)
if(any(pjoint_Z_g_01<0)){stop("pjoint_Z_g_01 is not legistimate !")}
pjoint_Z_g_00 = J3_Pjoint_Z_g_XG.f(K1, K2, K3, eta_1_vec, eta_2_vec, eta_3_vec, 0, 0, pi_pair_mat,
pi_pair_mat.res$pi11, pi_pair_mat.res$pi22,
pi_pair_mat.res$pi33, pi_pair_mat.res$pi12,
pi_pair_mat.res$pi13, pi_pair_mat.res$pi23)
if(any(pjoint_Z_g_00<0)){stop("pjoint_Z_g_00 is not legistimate !")}
K= K1+K2+K3
l <- rep(list(0:1), K)
Zmat <- expand.grid(l)
reZmat = rbind(Zmat[rowSums(Zmat)<=1,],
Zmat[rowSums(Zmat)==2,],
Zmat[rowSums(Zmat)>=3,])
R1 = length(brks_1_vec)+1; R2 = length(brks_2_vec)+1; R3 = length(brks_3_vec)+1
m=
1
set.seed(m)
# generate XGmat
XGmat = gen_XG.f(nsample, prob.x, prob.g)
xgInd_11 = XGmat[,1]*XGmat[,2]; xgInd_10 = XGmat[,1]*(1-XGmat[,2])
xgInd_01 = (1-XGmat[,1])*XGmat[,2]; xgInd_00 = (1-XGmat[,1])*(1-XGmat[,2])
n_11 = sum(xgInd_11); n_10 = sum(xgInd_10); n_01 = sum(xgInd_01); n_00 = sum(xgInd_00)
# generate Z_g_XG
Z_11 = gen_Z_g_XG.f(n_11, pjoint_Z_g_11, reZmat)$genZmat
Z_10 = gen_Z_g_XG.f(n_10, pjoint_Z_g_10, reZmat)$genZmat
Z_01 = gen_Z_g_XG.f(n_01, pjoint_Z_g_01, reZmat)$genZmat
Z_00 = gen_Z_g_XG.f(n_00, pjoint_Z_g_00, reZmat)$genZmat
reXGmat = rbind(XGmat[xgInd_11==1,], XGmat[xgInd_10==1,],
XGmat[xgInd_01==1,], XGmat[xgInd_00==1,])
trueZmat = rbind(Z_11, Z_10, Z_01, Z_00)
# generate T
#system.time(trueTmat <- gen_T.f(K1, K2, K3, nsample, alp_1_vec, alp_2_vec, alp_3_vec, brks_1_vec, brks_2_vec, brks_3_vec,cor_mat))
trueTmat <- gen_T_wei.f(K1, K2, K3, nsample, scale_1, kappa_1,  scale_2, kappa_2,
scale_3, kappa_3,cor_mat)
# generate visitTime
visitTime <- t(hpp.sim(visit.rate, visit.rate*2, num.sims=nsample))
# generate indata_s1.list (each element corresponds to (j,k))
indata_s1_1.list <- mclapply(1:K1, function(k){
gen_indata_s1_jk.f(1, k, nsample, trueTmat[, k], trueZmat[,k], reXGmat, visitTime)
}, mc.cores=2)
indata_s1_2.list <- mclapply((1:K2), function(k){
gen_indata_s1_jk.f(2, k, nsample, trueTmat[, K1+k], trueZmat[,K1+k], reXGmat, visitTime)
}, mc.cores=2)
indata_s1_3.list <- mclapply((1:K3), function(k){
gen_indata_s1_jk.f(3, k, nsample, trueTmat[, K1+K2+k], trueZmat[, K1+K2+k], reXGmat, visitTime)
}, mc.cores = 2)
indata_s1.list <- c(indata_s1_1.list, indata_s1_2.list, indata_s1_3.list)
library(mipfp)
library(Rsolnp)
library(MASS)
library(NlcOptim)
library(eha) #
library(parallel)
library(mnormt)#
library(poisson)
source("dataGen_fcts.R")
source("TwoStage_est_fct.R")
setwd("~/Dropbox/richard/coding-pj2/sim2")
source("dataGen_fcts.R")
source("TwoStage_est_fct.R")
source("prepare_param_sim.R")
source("TwoStage_inference_fct.R")
Jtype=2
KJjoint=2
gam2=c(0.5,0.5)
prob.g=0.1
pi.marg.j=c(0.65,0.75)
visit.rate=20
pair.asso.type="jjp"
gene.effect.type="common"
delta=1e-03
param.res.list <- param.gen.f(Jtype=Jtype, KJjoint=KJjoint, prob.g=prob.g,
pi.marg.j=pi.marg.j, gam2=gam2)
FT.param.list <- param.res.list$FT.param.list
Z.param.list <- param.res.list$Z.param.list
X.param.list <- param.res.list$X.param.list
G.param.list <- param.res.list$G.param.list
Rj_vec <- unlist(lapply(1:length(FT.param.list$brks.list),function(j){length(FT.param.list$brks.list[[j]])+1}))
sim
sim=1
set.seed(sim)
# generate data
pre_data <- gen.data.f(nsample, Jtype, KJjoint,
FT.param.list, Z.param.list,
X.param.list, G.param.list)
# prepare indata_s1
indata_s1 <- get.data.s1.f(nsample, Jtype, KJjoint, XG=pre_data$XG,
FT=pre_data$FT, Z=pre_data$Z, visit.rate=visit.rate)
head(indata_s1)
write.table(indata_s1, file = "indata_s1.txt", sep = "\t",
row.names = FALSE)
1/exp(-3.658229)
1/exp(-1.373277)
beta0_vec = c(-0.2, 0, 0.2)
beta1_vec = c(0, 0.3, 0.5)
OR_vec = c(1, 2)
q_C = c(0.1, 0.3)
P1= c(0.2, 0.5)
covar.mat <- expand.grid(beta0_vec, beta1_vec, OR_vec, q_C, P1)
covar.mat
log(2)
-log(2)
log(1.5)
